#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Making Legacy Fortran Code Type Safe through Source-to-source Compilation
\end_layout

\begin_layout Author
Wim Vanderbauwhede
\end_layout

\begin_layout Abstract
In this paper we present the program transformations and type checking algorithm
s required to convert FORTRAN 77 subroutines and functions into pure, side-effec
t free subroutines and functions in Fortran 95.
 The resulting code is type safe and the pure, side-effect free and referentiall
y transparent subroutines can readily be offloaded to accelerators.
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Fortran still matters
\end_layout

\begin_layout Standard
Show bibliographic data, Archer load, see other paper
\end_layout

\begin_layout Subsection
Acceleration by offloading matters
\end_layout

\begin_layout Standard
Hardware accelerators have proven extremely effective in accelerating scientific
 code.
 Of the Green Top 10 (https://www.top500.org/lists/green500/2019/11/), 8 systems
 use accelerators.
 However, in practice the accelertors have their own memory, and the most
 common compute model is still to offload part of the calculation to the
 accelerator and copy the results back to the host memory.
 Even if the accelerator is cache-coherent with the host memory, having
 the code to be run on the accelertor in a separate memory space is still
 advantageous as it results in reduced coherency traffic.
\end_layout

\begin_layout Standard
Cite success of heterogeneous supercomputers etc
\end_layout

\begin_layout Subsection
The need for pure functions
\end_layout

\begin_layout Standard
Therefore we need self-contained ("pure") functions
\end_layout

\begin_layout Standard
- no shared memory space - no system calls - no library calls except intrinsic
 ones - no I/O
\end_layout

\begin_layout Subsection
The case for type safety
\end_layout

\begin_layout Standard
In his paper, 
\begin_inset Quotes eld
\end_inset

A Theory of Type Polymorphism in Programming
\begin_inset Quotes erd
\end_inset

 [REF], Robin Milner expressed the notion of type safety as “Well typed
 programs cannot go wrong.” By 
\begin_inset Quotes eld
\end_inset

going wrong
\begin_inset Quotes erd
\end_inset

 we mean in general not computing the expected result.
 There are several components contributing to this behaviour: one is the
 language's type system, the other is the type checker, and finally there
 is the actual program code.
 
\end_layout

\begin_layout Standard
In a type-safe language, the language’s type system ensures programs cannot
 perform operations that are not compatible with the types of the operands
 involved, i.e.
 there are no type errors in a well-typed program written in a type-safe
 language.
 By type error we mean an error arising from the fact that a variable (or
 constant or function) with a given type is treated as if it has a different
 type.
 
\end_layout

\begin_layout Standard
A type checker is called 
\emph on
sound 
\emph default
if it only accepts correctly typed programs.
 However, the fact that a sound typechecker accepts a correctly typed program
 does not mean the program is correct.
 
\end_layout

\begin_layout Standard
In the context of Fortran, the type system as specified in 
\begin_inset Quotes eld
\end_inset

ANSI X3.9-1978 – American National Standard Programming Language FORTRAN
\begin_inset Quotes erd
\end_inset

 [REF], hereafter called the 
\begin_inset Quotes eld
\end_inset

f77 specification
\begin_inset Quotes erd
\end_inset

, is not type-safe.
 It is possible to write programs which the type checker accepts but are
 nonetheless incorrect.
 The key culprit for this is the type erasure which happens when data is
 handled via COMMON or EQUIVALENCE.
 The subset of Fortran 90 which we target in this paper, and which we can
 loosely define as FORTRAN 77 without COMMON or EQUIVALENCE statements,
 with pure functions and referential transparency, and using Fortran 90
 style type declarations, is type safe and well typed programs in this subset
 will not go wrong if they are accepted by the type checker.
 
\end_layout

\begin_layout Standard
Therefore, if we can extended the FORTRAN 77 type system to be type-safe,
 then programs accepted by the extended type checker are well typed.
 If these programs are
\end_layout

\begin_layout Standard
automatically converted into code written in this Fortran 90 subset, then
 an ordinary Fortran compiler can be used as the type checker with all type-base
d warnings turned into errors, and the code will type check cleanly.
 
\end_layout

\begin_layout Standard
This paper presents such an extended type system and type checks as well
 as the algorithms required to convert FORTRAN 77 into type-safe Fortran
 90.
\end_layout

\begin_layout Section
Related work: 
\end_layout

\begin_layout Standard
see earlier paper, be nice to CamFort
\end_layout

\begin_layout Section
Preliminaries
\end_layout

\begin_layout Standard
2.13 Storage A storage sequence is a sequence of storage units.
 A storage unit is either a numeric storage unit or a character storage
 unit.
 An integer, real, or logical datum has one numeric storage unit in a storage
 sequence.
 A double precision or complex datum has two numeric storage units in a
 storage sequence.
 A character datum has one character storage unit in a storage sequence
 for each character in the datum.
 This standard does not specify a relationship between a numeric storage
 unit and a character storage unit.
 If a datum requires more than one storage unit in a storage sequence, those
 storage units are consecutive.
 The concept of a storage sequence is used to describe relationships that
 exist among variables, array elements, arrays, substrings, and common blocks.
 This standard does not specify a relationship between the storage sequence
 concept and the physical properties or implementation of storage.
\end_layout

\begin_layout Standard
The six types of data are: (1) Integer (2) Real (3) Double precision A double
 precision datum has two consecutive numeric storage units in a storage
 sequence (4) Complex A complex datum is a processor approximation to the
 value of a complex number.
 The representation of a complex datum is in the form of an ordered pair
 of real data.
 The first of the pair represents the real part of the complex datum and
 the second represents the imaginary part.
 Each part has the same degree of approximation as for a real datum.
 A complex datum has two consecutive numeric storage units in a storage
 sequence; the first storage unit is the real part and the second storage
 unit is the imaginary part.
 (5) Logical (6) Character
\end_layout

\begin_layout Standard
https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Language.html
\end_layout

\begin_layout Standard
The standard does not specify the size of a numeric storage unit, nor does
 it speficy a relationship between a numeric storage unit and a character
 storage unit.
 However, the consensus amongst Fortran compilers is as follows:
\end_layout

\begin_layout Standard
(1) Integer: 4 (2) Real: 4 (3) Double precision: 8 (4) Complex: 8, Double
 Complex: 16 (5) Logical: 4 (6) Character: 1
\end_layout

\begin_layout Standard
Technically, the use of kinds in type declarations is not part of the FORTRAN
 77 specification.
 It is however widely used and supported by all current Fortran compilers,
 in particular g77.
 Therefore we treat all types as (typename, kind) tuples.
 This allows us the simplify the types to integer, real, logical and character,
 because we write 
\end_layout

\begin_layout Standard
Double precision: (real,8) Comples: ((real,4),(real,4)) Double Complex ((real,8)
,(real,8))
\end_layout

\begin_layout Subsection
How type-safe is FORTRAN 77?
\end_layout

\begin_layout Standard
We start by considering a FORTRAN 77 program that consists of pure functions
 or subroutines (see below for a formal definition) and where all variables,
 parameters and functions are explicitly typed.
 We will see later how to achieve fully explicity typing and under which
 conditions a subroutine or function can be made pure.
 
\end_layout

\begin_layout Standard
According to §4.1 
\begin_inset Quotes eld
\end_inset

Data Types
\begin_inset Quotes erd
\end_inset

 of the f77 specification, the six types of data are:
\end_layout

\begin_layout Enumerate
Integer
\end_layout

\begin_layout Enumerate
Real
\end_layout

\begin_layout Enumerate
Double precision
\end_layout

\begin_layout Enumerate
Complex
\end_layout

\begin_layout Enumerate
Logical
\end_layout

\begin_layout Enumerate
Character
\end_layout

\begin_layout Standard
The f77 specification discusses each of these types in terms of their 
\emph on
storage units
\emph default
.
 According to §2.13 
\begin_inset Quotes eld
\end_inset

Storage
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

A storage unit is either a numeric storage unit or a character storage unit.
 An integer, real, or logical datum has one numeric storage unit in a storage
 sequence.
 A double precision or complex datum has two numeric storage units in a
 storage sequence.
 A character datum has one character storage unit in a storage sequence
 for each character in the datum.
 This standard does not specify a relationship between a numeric storage
 unit and a character storage unit.
 If a datum requires more than one storage unit in a storage sequence, those
 storage units are consecutive.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
An integer or real has one storage unit
\end_layout

\begin_layout Itemize
A 
\emph on
double precision
\emph default
 datum has two consecutive numeric storage units in a storage sequence (§4.5
 Double Precision Type).
\end_layout

\begin_layout Itemize
A 
\emph on
complex
\emph default
 datum is a processor approximation to the value of a complex number.
 The representation of a complex datum is in the form of an ordered pair
 of real data.
 The first of the pair represents the real part of the complex datum and
 the second represents the imaginary part.
 Each part has the same degree of approximation as for a real datum.
 A complex datum has two consecutive numeric storage units in a storage
 sequence; the first storage unit is the real part and the second storage
 unit is the imaginary part (§4.6 Complex Type).
\end_layout

\begin_layout Standard
As quoted above, the f77 specification does not specify the size of a storage
 unit.
 However, the consensus amongst Fortran compilers is as follows:
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size in bytes (Kind)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#Storage Units (numeric)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Real
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Double precision
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logical
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size in bytes 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#Storage Units (character)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Relationship between storage unit, kind and bytes for FORTRAN 77 types.
\begin_inset CommandInset label
LatexCommand label
name "tab:Relationship-between-storage"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Various extensions exists such as Byte, Double complex etc.
 Technically, the use of Kinds in type declarations (e.g.
 integer*8) is not part of the f77 specification.
 It is however widely used and supported by all current Fortran compilers,
 specifically the open source GNU Fortran compiler g77.
 In this paper we effectively consider FORTRAN 77 to be defined by the f77
 specification combined with the g77 extensions https://gcc.gnu.org/onlinedocs/gcc
-3.4.6/g77/Language.html.
 
\end_layout

\begin_layout Standard
We will treat the kind as the number of bytes of storage as in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Relationship-between-storage"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and define the scalar types as (Typename, Kind) tuples.
 Moreover, we define a character storage unit as 1 byte.
 This allows us the simplify the types to integer, real, complex and logical,
 because we can write:
\end_layout

\begin_layout Standard
Double precision: (real,8)
\end_layout

\begin_layout Standard
Complex: ((real,4),(real,4)) – not sure!
\end_layout

\begin_layout Standard
Double Complex ((real,8),(real,8)) – not sure!
\end_layout

\begin_layout Standard
Character: (integer,1)
\end_layout

\begin_layout Standard
For the rest of the discussion we will treat the character type as an integer
 with a kind of 1 and a character string as an array of characters.
\end_layout

\begin_layout Standard
Fortran's type system in this context 
\end_layout

\begin_layout Standard
Type = 
\begin_inset Formula $\left\{ Integer,Real,Complex,Logical\right\} $
\end_inset


\end_layout

\begin_layout Standard
Kind = 
\begin_inset Formula $\left\{ 2^{n}|\;n\in[0,5]\right\} $
\end_inset


\end_layout

\begin_layout Standard
Scalar = 
\begin_inset Formula $\left\{ Type\times Kind\right\} $
\end_inset

, and we will denote an element of this set as 
\emph on
Scalar t k
\end_layout

\begin_layout Standard
Dim =
\begin_inset Formula $\left\{ ((s_{1},e_{i}),...,(s_{i},e_{i}),...,(s_{k},e_{k})),\forall k,i\in\,[1,7],s_{i},e_{i}\in\mathbb{Z},s_{i}\le e_{i}\right\} $
\end_inset

, so Dim is a set of ordered sets of tuples, we denote an element as 
\emph on
Dim d
\end_layout

\begin_layout Standard
Array = 
\begin_inset Formula $\left\{ Scalar\times Dim\right\} $
\end_inset

, and we will denote an element of this set as 
\emph on
Array (Scalar t k) (Dim d)
\end_layout

\begin_layout Standard
FortranType = 
\begin_inset Formula $Scalar\cap Array$
\end_inset


\end_layout

\begin_layout Standard
To investigate the type safety, we need to consider the typing rules for
\end_layout

\begin_layout Standard
- scalars
\end_layout

\begin_layout Standard
- array declarations
\end_layout

\begin_layout Standard
- array accesses 
\end_layout

\begin_layout Standard
- function and subroutine declarations
\end_layout

\begin_layout Standard
- expressions
\end_layout

\begin_layout Standard
- assignments
\end_layout

\begin_layout Standard
- function and subroutine calls
\end_layout

\begin_layout Standard
The typing rule for a scalar s is simply that any occurence of a scalar
 variable must have the same type, which must be the type from its declaration
 and belong to the set 
\emph on
Scalar
\emph default
.
 we write this as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
s:\tau_{s}=Scalar\,t\,k
\]

\end_inset


\end_layout

\begin_layout Standard
The typing rules for an array are that in addition to being of a valid Scalar
 type it must have a non-empty Dim set, 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
a:\tau_{a}=Array\,\tau_{s}\ (Dim\,d),d=((s_{1},e_{i}),...,(s_{i},e_{i}),...,(s_{k},e_{k}))
\]

\end_inset


\end_layout

\begin_layout Standard
and for any array access 
\begin_inset Formula $a(j_{1},...,j_{k}),j_{i}\in[s_{i},e_{i}]$
\end_inset

 the number indices must XXX, each index must be within bounds and the type
 must be the scalar type:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
a(j_{1},...,j_{i},...,j_{k}):\forall\,i\in[1,k]|j_{i}\in[s_{i},e_{i}]\Rightarrow\tau_{s}
\]

\end_inset


\end_layout

\begin_layout Standard
The subroutine declaration typing rule is that every dummy argument must
 be of a valid FortranType:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
s(a_{1},...,a_{i},...,a_{m})\,|\,a_{i}:FortranType,\forall i\in[1,m],m\in\mathbb{N}
\]

\end_inset


\end_layout

\begin_layout Standard
The function declaration typing rule is that every dummy argument and the
 function itself must be of a valid FortranType:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f(a_{1},...,a_{i},...,a_{m})\,|\,f:FortranType,a_{i}:FortranType,\forall i\in[1,m],m\in\mathbb{N}
\]

\end_inset


\end_layout

\begin_layout Standard
Expressions
\end_layout

\begin_layout Standard
Assignments
\end_layout

\begin_layout Subsection
The definition of a pure function
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\Gamma$
\end_inset

 be the context of a given program, i.e.
 the set of all variables with their current value and type:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\{...,x_{i}:\tau_{i}=v_{i},...\}
\]

\end_inset


\end_layout

\begin_layout Standard
Consider a function 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
y & = & f(x_{1},...,x_{N})\\
y:\tau_{y}\\
x_{i}:\tau_{i},i\in[1,N]
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
and for convenience we'll write 
\begin_inset Formula $x_{1},...,x_{N}$
\end_inset

 as 
\begin_inset Formula $\overrightarrow{x}$
\end_inset

 and its type as 
\begin_inset Formula $\overrightarrow{\tau}$
\end_inset

.
\end_layout

\begin_layout Standard
This function is 
\emph on
pure
\emph default
 iff
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\forall\,\Gamma,\forall\overrightarrow{x}\in\Gamma,\exists!y\in\Gamma:y=f(\overrightarrow{x})
\]

\end_inset


\end_layout

\begin_layout Standard
In words, whatever the environment, for a given set of argument values of
 the correct type, the function will always return the same value.
 
\end_layout

\begin_layout Standard
In the equations below, the subscript 
\emph on
c
\emph default
 (
\begin_inset Quotes eld
\end_inset

caller
\begin_inset Quotes erd
\end_inset

) is used for the variables declared in the caller of a subroutine and 
\emph on
l
\emph default
 (
\begin_inset Quotes eld
\end_inset

local
\begin_inset Quotes erd
\end_inset

) for the variables declared by in subroutine.
 
\end_layout

\begin_layout Subsection
Explicit typing
\end_layout

\begin_layout Standard
According to §4.1.2 of the f77 specification, in FORTRAN 77 a variable 
\begin_inset Quotes eld
\end_inset

may have its type specified in a type-statement (8.4) as integer, real, double
 precision, complex, logical, or character.
 In the absence of an explicit declaration in a type-statement, the type
 is implied by the first letter of the name.
 A first letter of I, J, K, L, M, or N implies type integer and any other
 letter implies type real, unless an IMPLICIT statement (8.5) is used to
 change the default implied type.
\begin_inset Quotes erd
\end_inset

 An IMPLICIT statement specifies a type for all variables that begin with
 any letter that appears in the specification.
 
\end_layout

\begin_layout Standard
From a type safety perspective, the problem with this typing discipline
 is no 
\emph on
referential transparency
\emph default
, i.e.
 if the name of a variable changes then the result of a computation may
 change.
 As our aim is to create pure functional code, our compiler infers explicity
 type declarations (
\begin_inset Quotes eld
\end_inset

type-statements
\begin_inset Quotes erd
\end_inset

 in the F77 spec) for all implicity typed variables.
 
\end_layout

\begin_layout Standard
The algorithm for this is straightforward:
\end_layout

\begin_layout Enumerate
Parse all IMPLICIT statements and turn them into a lookup table {Char =>
 (Type,ArrayOrScalar,Attribute)}.
 This lookup table is initially populated with the default rule: implicit
 integer (i-n), real (a-h, o-z)
\end_layout

\begin_layout Enumerate
Analyse all executable statements for occurences of undeclared variables
 and add declarations following the IMPLICIT rules, i.e
\end_layout

\begin_deeper
\begin_layout Enumerate
Get the first character
\end_layout

\begin_layout Enumerate
Look up the type in the lookup table
\end_layout

\begin_layout Enumerate
Create a type declaration 
\end_layout

\end_deeper
\begin_layout Enumerate
Add the created declarations before the first executable statement
\end_layout

\begin_layout Enumerate
Add IMPLICIT NONE before the first non-executable statement to specify that
 no implicit typing should be done in the generated code
\end_layout

\begin_layout Subsection
Removal of COMMON blocks
\end_layout

\begin_layout Standard
From the spec:
\end_layout

\begin_layout Standard
The COMMON statement provides a means of associating entities in different
 program units.
 This allows different program units to define and reference the same data
 without using arguments, and to share storage units.
\end_layout

\begin_layout Standard
(From the F95 spec: "The COMMON statement specifies blocks of physical storage,
 called common blocks, that may be accessed by any of the scoping units
 in a program.
 Thus, the COMMON statement provides a global data facility based on storage
 association.
\end_layout

\begin_layout Standard
Storage sequences are used to describe relationships that exist among variables,
 common blocks, and result variables.
 Storage association is the association of two or more data objects that
 occurs when two or more storage sequences share or are aligned with one
 or more storage units.
 " )
\end_layout

\begin_layout Standard
Our approach is to convert COMMON block variables into subroutine arguments.
 The more common approach of conversion into module-scoped variables is
 not suitable for our purpose because it does not result in pure functions.
 (Furthermore, because of the difference in semantics of storage association
 and module scoped variables, this approach only works for COMMON blocks
 where all variables are aligned, whereas COMMON blocks allow overlapping
 sequences).
 One of the main contributions of this paper is in this conversion and the
 associated type checks.
\end_layout

\begin_layout Subsubsection
Construct the COMMON block chain
\end_layout

\begin_layout Standard
In a subroutine call chain, it is not necessary for a COMMON blocks to occur
 in the caller.
 It is sufficient that the COMMON block used in a called subroutine occurs
 somewhere in the call chain.
 As a consequence, it is not generally possible to associate the COMMON
 block variables in a called subroutine with those of the caller.
 For example:
\end_layout

\begin_layout LyX-Code
progam ex1
\end_layout

\begin_layout LyX-Code
common /bf2/x 
\end_layout

\begin_layout LyX-Code
common /bf1/y
\end_layout

\begin_layout LyX-Code
call f1
\end_layout

\begin_layout LyX-Code
end program ex1
\end_layout

\begin_layout LyX-Code
subroutine f1 
\end_layout

\begin_layout LyX-Code
common /bf1/y1 
\end_layout

\begin_layout LyX-Code
call f2 
\end_layout

\begin_layout LyX-Code
end subroutine f1
\end_layout

\begin_layout LyX-Code
subroutine f2 
\end_layout

\begin_layout LyX-Code
common /bf2/x2 
\end_layout

\begin_layout LyX-Code
end subroutine f2
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
In this example, x2 in f2 is associated with x in the main program 
\end_layout

\begin_layout LyX-Code
progam ex1 
\end_layout

\begin_layout LyX-Code
call f1(x,y) 
\end_layout

\begin_layout LyX-Code
end program ex1
\end_layout

\begin_layout LyX-Code
subroutine 
\end_layout

\begin_layout LyX-Code
f1(x,y1) 
\end_layout

\begin_layout LyX-Code
call f2(x) 
\end_layout

\begin_layout LyX-Code
! ...
 use y1 ...
 
\end_layout

\begin_layout LyX-Code
end subroutine f1
\end_layout

\begin_layout LyX-Code
subroutine f2(x2) 
\end_layout

\begin_layout LyX-Code
! ...
 use of x2 
\end_layout

\begin_layout LyX-Code
end subroutine f2
\end_layout

\begin_layout Standard
So the argument for f2 has to be passed via f1 from the main program.
 Therefore, we need to analyse the code for the call chain paths between
 disjoint COMMON blocks and pass all arguments via the intervening calls.
 This also requires checking if the names are unique an renaming if necessary.
 The result of this analysis is that for every called subroutine, we have
 a pair consisting of the common block sequence that will become the call
 arguments, and the common block sequence that will become the dummy arguments.
 
\end_layout

\begin_layout Subsubsection
The actual conversion
\end_layout

\begin_layout Standard
To create the call arguments and dummy arguments, we need to identify which
 variable in the caller sequence matches which in the subroutine call sequence
 (called the 'local' sequence for brevity).
 This is complicated by the fact that storage sequences are allowed to overlap,
 and do not follow the normal type checking rules.
 For example, the following is acceptable:
\end_layout

\begin_layout LyX-Code
! caller 
\end_layout

\begin_layout LyX-Code
real xc(8),z1c,z2c 
\end_layout

\begin_layout LyX-Code
complex yc 
\end_layout

\begin_layout LyX-Code
common yc,xc,zx
\end_layout

\begin_layout LyX-Code
! local real xl(2),zl(4) 
\end_layout

\begin_layout LyX-Code
complex yl(3) 
\end_layout

\begin_layout LyX-Code
common yl,xl,zl
\end_layout

\begin_layout Standard
yl(1) will be associated with yc(1) yl(2) will be associated with xl(1)
 and xl(2) yl(3) will be associated with zl(1) and zl(2) zl(3) will be associate
d with z1c zl(4) will be associated with z2c
\end_layout

\begin_layout Standard
Furthermore, we need to type check the associations, because COMMON blocks
 are not type safe: the association does not cause type conversion or imply
 mathematical equivalence.
 
\end_layout

\begin_layout Standard
XXX algos here XXX
\end_layout

\begin_layout Section
Removal of EQUIVALENCE statements
\end_layout

\begin_layout Standard
According to §8.2 of the F77 spec , "An EQUIVALENCE statement is used to
 specify the sharing of storage units by two or more entities in a program
 unit.
 This causes association of the entities that share the storage units.
 If the equivalenced entities are of different data types, the EQUIVALENCE
 statement does not cause type conversion or imply mathematical equivalence.
 If a variable and an array are equivalenced, the variable does not have
 array properties and the array does not have the properties of a variable."
\end_layout

\begin_layout Standard
This is another form of storage association, with the same issue that it
 is not type-safe.
 For example
\end_layout

\begin_layout LyX-Code
XXX example XXX
\end_layout

\begin_layout Standard
Therefore, EQUIVALENCE statements also need to be refactored.
 They come with their own flavour of complications.
 
\end_layout

\begin_layout Standard
if a line has multiple tuples, this is allowed: 
\end_layout

\begin_layout Standard
(v1,v2),(v2,v3) 
\end_layout

\begin_layout Standard
So we must effectively do a transitivity check across all tuples.
 We do this by checking if an element of a tuple occurs in another tuple.
 It is sufficient to do this for a single element because the transivity
 means that every element from the one tuple will be associated with every
 element from the other.
\end_layout

\begin_layout Standard
Furthermore, the tuples (called lists in the spec) can have more than two
 elements.
 
\end_layout

\begin_layout Standard
(v1,v2,v3),(v3,v4,v5) 
\end_layout

\begin_layout Standard
then this effectively means (v1,v2,v3,v4,v5) and each of these variables
 is associated with all the others, so there are 10 unique associations
 in this example.
 In general, for a tuple of n values, there will be (n-1)*n/2 associations.
\end_layout

\begin_layout Standard
Another complication is that overlapping is allowed, e.g.:
\end_layout

\begin_layout Standard
DIMENSION RADE11(5), RADE12(5) 
\end_layout

\begin_layout Standard
EQUIVALENCE (RADE11(4), RADE12(2))
\end_layout

\begin_layout Standard
Because the arrays start at 1, and they overlap, this actually creates an
 equivalence between `RADE11(3), RADE12(1)` and `RADE11(5), RADE12(3)` as
 well.
 So we have to equate the overlapping ranges.
\end_layout

\begin_layout Section
INTENT inference 
\end_layout

\begin_layout Standard
Because the subroutines to be offloaded cannot contain external calls or
 I/O calls, we can infer the intent of all arguments by recursive descent
 into nested calls.
\end_layout

\begin_layout Subsection*
Typechecking COMMON block and EQUIVALENCE associations 
\end_layout

\begin_layout Standard
Variables stored in COMMON blocks lose all type information.
 This means in particular that there is no type coercion between real and
 integer values.
 To ensure type safety before refactoring, if a COMMON block is used to
 pass arguments to a subroutine, our compiler will perform typechecks.
 Because of the lack of coercion, these checks are different from the typechecks
 performed for normal assignments or arguments passed to subroutines via
 dummy parameters.
 The same is true for EQUIVALENCE statements: they associate different names
 with the same memory location, but the type of the word written to the
 memory location is erased.
 Therefore, the following is legal and does not generate any warnings, but
 is incorrect
\end_layout

\begin_layout LyX-Code
integer*4 i1
\end_layout

\begin_layout LyX-Code
real*4 r1       
\end_layout

\begin_layout LyX-Code
equivalence (i2,r1)
\end_layout

\begin_layout LyX-Code
i1 = 42
\end_layout

\begin_layout LyX-Code
print *, r1 ! prints 5.88545355E-44
\end_layout

\begin_layout LyX-Code
r1 = 42
\end_layout

\begin_layout LyX-Code
print *, i1 ! prints 1109917696
\end_layout

\begin_layout Standard
For the purpose of typechecking, we can assume that all variables are scalar:
 an array a is considered as syntactic sugar for an ordered collection of
 scalars with names a(i).
 We further assume all arrays are linear and traversed using an index starting
 at 1.
 
\end_layout

\begin_layout Standard
The main rule for type soundness which we adopt are:
\end_layout

\begin_layout Itemize
Kind matching (rule-kind)
\end_layout

\begin_deeper
\begin_layout Standard
A scalar type is atomic, and therefore we cannot split the type, which would
 be the case if we attempted to map types with different kinds.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 & K_{c,i}=K_{l,i} & ,\forall i\in\#K_{l}
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
No COMMON block extension in the called subroutine (rule-size)
\end_layout

\begin_deeper
\begin_layout Standard
The ordered set of words in a COMMON block accessed from a subroutine must
 be no larger than the size of the COMMON block in the caller.
 
\end_layout

\begin_layout Standard
If W is the ordered set of all words accessed via the COMMON block then
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 & \#W_{l}\leq\#W_{c}
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Logical coercion (rule-logical)
\end_layout

\begin_deeper
\begin_layout Standard
The next rule is that all types must match between the sequence of variables
 in the caller and the called subroutine.
 However, this rule is too strict: there are several cases in which type
 coercion is sound.
 The first case involves logicals:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 &  & \begin{cases}
T_{c,i}=\mbox{logical}\land T_{l,i}=\mbox{integer}\\
T_{c,i}=\mbox{integer}\land T_{l,i}=\mbox{logical}\\
T_{c,i}=\mbox{real}\land T_{l,i}=\mbox{logical}
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
A logical is false when coerced from 0 and true otherwise.
 Therefore interpreting a logical as an integer gives 1 or 0, and interpreting
 an integer or real as a logical will return correct values of .true.
 or .false.
 .
 Note that Therefore interpreting a logical as a real is only correct for
 .false.
 because the .true.
 interpreted as a real is a non-zero number that depends on the kind of
 the real.
 As this is quite non-intuitive, our typechecker therefor throws an error
 on attempts to interpret a logical as a real.
\end_layout

\end_deeper
\begin_layout Itemize
Complex coercion (rule-complex)
\end_layout

\begin_deeper
\begin_layout Standard
The next case involves complex numbers, which can be coerced to and from
 two contiguous real numbers:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 &  & \begin{cases}
T_{c,i}=\mbox{complex}\land T_{l,i}=\mbox{real}\land T_{l,i+1}=\mbox{real}\\
T_{c,i}=\mbox{real}\land T_{c,i+1}=\mbox{real}\land T_{l,i}=\mbox{complex}
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Default rule (rule-default)
\end_layout

\begin_deeper
\begin_layout Standard
In all other cases, the types must match:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 & T_{l,i}=T_{c,i} & ,\forall i\in\#K_{l}
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
So the overall typecheck rule is as follows:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 & \mbox{rule-kind\land}\mbox{rule-size\land}\left(\mbox{rule-logical}\lor\mbox{rule-complex}\lor\mbox{rule-default}\right)
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection*
Matching up COMMON block variables in a subroutine call
\end_layout

\begin_layout Standard
Given that the typecheck succeeds, then it follows that for every variable
 in a COMMON block declared in the caller, there is a corresponding variable
 in the called subroutine.
 In practice these variables can be either arrays or scalars.
 Whereas for the purpose of typechecking we have assumed that all variables
 are scalar, without loss of generality, we will now assume that all variables
 are arrays.
 A scalar s is simply syntactic sugar for the first element of an array
 of size 1, s(1).
 This is merely to keep the rules more compact.
 As before, we traverse every array using a linear index starting at 1.
\end_layout

\begin_layout Standard
Because it is possible for arrays from the caller and arrays in the called
 subroutine to overlap in both directions, our strategy for converting the
 COMMON variables into dummy parameters is as follows: 
\end_layout

\begin_layout Itemize
we declare dummy parameters with the names of the variables in the caller
 (prefixed with the name of the caller and the COMMON block).
 
\end_layout

\begin_layout Itemize
Then we determine the assignments required to match these dummy parameters
 with the variables that used to be COMMON block variables in the caller
 subroutine, but now are ordinary local variables.
 
\end_layout

\begin_layout Itemize
We insert these assignments after the last specification statement.
 
\end_layout

\begin_layout Itemize
At the end of the subroutine, we insert the corresponding reverse assignments.
\end_layout

\begin_layout Itemize
If required, the right-hand side of the assignment will contain an explicit
 cast and/or a reshape instruction, because it is possible that the arrays
 in the caller and the called subroutine have different shapes.
\end_layout

\begin_layout Standard
The compiler maintains a global state record.
 The state information of each subroutine, 
\emph on
st
\emph default
, is used in 
\family typewriter
updateDim
\family default
 for evaluation of the array bounds.
\end_layout

\begin_layout Standard
the sequence 
\emph on
cseq
\emph default
 consists of tuples of the type declaration 
\emph on
decl
\emph default
 and the linear index 
\emph on
idx
\emph default
 in the 
\family sans
COMMON
\family default
 block
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
cseq & = & (decl_{1},idx_{1}),...,(decl_{i},idx_{i}),...)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
For every array variable, the type declaration contains a 
\emph on
Dim 
\emph default
field 
\emph on
d
\emph default
 which is an array of (start index, end index) tuples, with total size 
\emph on
sz
\emph default
.
\end_layout

\begin_layout Standard
The list of equivalence pairs 
\emph on
eqps
\emph default
 contains the matched up declarations of the original 
\family sans
COMMON
\family default
 block variables of the called subroutine and the 
\family sans
COMMON
\family default
 block variables of the caller that constitute the new arguments to the
 subroutine.
 The caller variables are prefixed with the name of the block and the caller
 subroutine.
\end_layout

\begin_layout Standard
The matching algorithm traverses the local sequence 
\begin_inset Formula $\mathit{cseq}_{c}$
\end_inset

 and matches each element to one or more elements of the caller sequence
 
\begin_inset Formula $\mathit{cseq}_{l}$
\end_inset

.
 The algorithm is iterative and stops when the local sequence has been consumed,
 and returns 
\emph on
eqps
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
d_{l} & = & \begin{cases}
sz_{l}-\mathit{idx_{l}}>sz_{c}-idx_{c} & \mbox{updateDim}\,\mathit{st}_{l}\,d_{l}\,idx_{l}\,1\\
sz_{l}-idx_{l}<=sz_{c}-idx_{c} & \mbox{updateDim}\,\mathit{st}_{l}\,d_{l}\,idx_{l}\,idx_{l,e}
\end{cases}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
d_{c} & = & \begin{cases}
sz_{l}-idx_{l}=>sz_{c}-idx_{c} & \mbox{updateDim}\,\mathit{st}_{c}\,d_{c}\,idx_{c}\,1\\
sz_{l}-idx_{l}<sz_{c}-idx_{c} & \mbox{updateDim}\,st_{c}\,d_{c}\,idx_{c}\,idx_{c,e}
\end{cases}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathit{cseq}_{l} & = & \begin{cases}
sz_{l}-idx_{l}>sz_{c}-idx_{c} & \begin{cases}
sz_{l}-idx_{l,e}\geq1 & (\mathit{decl}_{l},idx_{l}+1)\bullet\mathit{cseq}_{l}\\
sz_{l}-idx_{l,e}<1 & \mathit{cseq}_{l}
\end{cases}\\
sz_{l}-idx_{l}\leq sz_{c}-idx_{c} & \mathit{cseq}_{l}
\end{cases}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathit{cseq}_{c} & = & \begin{cases}
sz_{l}-idx_{l}<sz_{c}-idx_{c} & \begin{cases}
sz_{c}-idx_{c,e}\geq1 & (\mathit{decl}_{c},idx_{c}+1)\bullet\mathit{cseq}_{c}\\
sz_{c}-idx_{c,e}<1 & \mathit{cseq}_{c}
\end{cases}\\
sz_{l}-idx_{l}\geq sz_{c}-idx_{c} & \mathit{cseq}_{c}
\end{cases}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathit{eqps} & = & \mathit{eqps}\bullet(\mathit{decl}_{l}\left\{ \mathit{Dim}=d_{l}\right\} ,\mathit{decl}_{c}\left\{ \mathit{Dim}=d_{c},\mathit{Prefix}=p\right\} )
\end{eqnarray}

\end_inset


\end_layout

\end_body
\end_document
